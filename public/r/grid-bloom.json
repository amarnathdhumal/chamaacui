{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "grid-bloom",
  "title": "Grid Bloom",
  "description": "A mesmerizing grid pattern with pulsing wave interference.",
  "dependencies": [
    "three",
    "@react-three/fiber",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/chamaac/grid-bloom/grid-bloom.tsx",
      "content": "\"use client\";\n\nimport { useRef, useMemo, useEffect } from \"react\";\nimport { Canvas, useFrame } from \"@react-three/fiber\";\nimport * as THREE from \"three\";\nimport { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nfunction cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nconst vertexShader = `\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n`;\n\nconst fragmentShader = `\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec3 uColor;\nuniform float uSpeed;\nuniform float uGridScale;\nuniform float uRotationSpeed;\nvarying vec2 vUv;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y / iResolution.x;\n    float value;\n\n    vec2 uv = fragCoord.xy / iResolution.x;\n    uv -= vec2(0.5, 0.5 * aspect);\n\n    // Animated rotation driven by uRotationSpeed\n    float rot = iTime * uRotationSpeed;\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    uv = m * uv;\n\n    uv += vec2(0.5, 0.5 * aspect);\n    uv.y += 0.5 * (1.0 - aspect);\n\n    // Grid density controlled by uGridScale\n    vec2 pos = uGridScale * uv;\n    vec2 rep = fract(pos);\n    float dist = 2.0 * min(min(rep.x, 1.0 - rep.x), min(rep.y, 1.0 - rep.y));\n\n    // Two offset pulse centers creating an interference pattern\n    vec2 cellCenter = floor(pos) + vec2(0.5);\n    float halfGrid = uGridScale * 0.5;\n    float dist1 = length(cellCenter - vec2(halfGrid * 0.7, halfGrid * 0.7));\n    float dist2 = length(cellCenter - vec2(halfGrid * 1.3, halfGrid * 1.3));\n\n    // Smoothly alternate between two pulse origins for interference\n    float pulseDist = mix(dist1, dist2, 0.5 + 0.5 * sin(iTime * 0.3 * uSpeed));\n\n    float edge = (iTime * uSpeed * 0.9 - pulseDist * 0.45) * 0.5;\n    edge = 2.0 * fract(edge * 0.5);\n\n    value = fract(dist * 2.0);\n    value = mix(value, 1.0 - value, step(1.0, edge));\n    edge = pow(abs(1.0 - edge), 2.0);\n    value = smoothstep(edge - 0.05, edge, 0.95 * value);\n    value += pulseDist * 0.08;\n\n    // Breathing brightness modulation\n    float breathe = 0.8 + 0.2 * sin(iTime * 0.5 * uSpeed);\n    value *= breathe;\n\n    fragColor = vec4(uColor, 1.0);\n    fragColor.a = 0.35 * clamp(value, 0.0, 1.0);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, vUv * iResolution);\n}\n`;\n\ninterface ShaderPlaneProps {\n  color: string;\n  speed: number;\n  gridScale: number;\n  rotationSpeed: number;\n}\n\nconst ShaderPlane = ({\n  color,\n  speed,\n  gridScale,\n  rotationSpeed,\n}: ShaderPlaneProps) => {\n  const materialRef = useRef<THREE.ShaderMaterial>(null);\n\n  const uniforms = useMemo(\n    () => ({\n      iTime: { value: 0 },\n      iResolution: { value: new THREE.Vector2() },\n      uColor: { value: new THREE.Color(color) },\n      uSpeed: { value: speed },\n      uGridScale: { value: gridScale },\n      uRotationSpeed: { value: rotationSpeed },\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  useEffect(() => {\n    uniforms.uColor.value.set(color);\n  }, [color, uniforms]);\n  useEffect(() => {\n    uniforms.uSpeed.value = speed;\n  }, [speed, uniforms]);\n  useEffect(() => {\n    uniforms.uGridScale.value = gridScale;\n  }, [gridScale, uniforms]);\n  useEffect(() => {\n    uniforms.uRotationSpeed.value = rotationSpeed;\n  }, [rotationSpeed, uniforms]);\n\n  useFrame((state) => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.iTime.value = state.clock.elapsedTime;\n      materialRef.current.uniforms.iResolution.value.set(\n        state.size.width * state.viewport.dpr,\n        state.size.height * state.viewport.dpr\n      );\n    }\n  });\n\n  return (\n    <mesh>\n      <planeGeometry args={[2, 2]} />\n      <shaderMaterial\n        ref={materialRef}\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        uniforms={uniforms}\n        depthWrite={false}\n        depthTest={false}\n        transparent={true}\n        blending={THREE.AdditiveBlending}\n      />\n    </mesh>\n  );\n};\n\nexport interface GridBloomProps {\n  className?: string;\n  /** Bloom color */\n  color?: string;\n  /** Overall animation speed multiplier */\n  speed?: number;\n  /** Density of the grid (higher = more tiles) */\n  gridScale?: number;\n  /** Speed of the slow grid rotation */\n  rotationSpeed?: number;\n}\n\nexport default function GridBloom({\n  className,\n  color = \"#e040fb\",\n  speed = 1.0,\n  gridScale = 12.0,\n  rotationSpeed = 0.08,\n}: GridBloomProps) {\n  return (\n    <div\n      className={cn(\n        \"w-full h-full absolute inset-0 pointer-events-none bg-purple-100\",\n        className\n      )}\n    >\n      <Canvas\n        camera={{ position: [0, 0, 1] }}\n        gl={{ antialias: false, alpha: true }}\n        dpr={[1, 2]}\n      >\n        <ShaderPlane\n          color={color}\n          speed={speed}\n          gridScale={gridScale}\n          rotationSpeed={rotationSpeed}\n        />\n      </Canvas>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:component"
}